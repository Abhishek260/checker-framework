\htmlhr
\chapter{Nondeterminism Checker\label{nondeterminism-checker}}

A nondeterministic program is one that may produce different outputs when
executed on the same input.  It is difficult for developer to debug a
nondeterministic program, and it can be hard for users to understand
results or compare executions.

One cause nondeterminism is calls to \<Random>.
Another common cause of nondeterminism in single-threaded programs is use
of hash tables, as in Java's \<HashMap> and \<HashSet> classes, whose
iteration order is undefined.  For example, this may produce output in a
different order:

\begin{Verbatim}
for (Object o : mySet) {
  System.out.println(o);
}
\end{Verbatim}

\noindent
and when used in an algorithm, computed values may be different.
On the other hand, certain \<Set> methods like \<contains> are deterministic.

The Nondeterminism Checker guarantees that
your program uses \<Random> and collections in a way that does not affect
the program's observable behavior.
the Nondeterminism Checker currently works on single-threaded programs;
it does not warn about potential nondeterminism due to concurrency.

To run the Nondeterminism Checker, supply the
\code{-processor NondeterminismChecker}
command-line option to javac.
For example:

\begin{Verbatim}
javac -processor org.checkerframework.checker.nondeterminism.NondeterminismChecker MyFile.java
\end{Verbatim}


\section{Nondeterminism type annotations\label{nondeterminism-annotations}}

The Nondeterminism type system uses the following annotations:
\begin{itemize}
\item
  \refqualclass{checker/nondeterminism/qual}{ValueNonDet} indicates
  that the collection can have possibly different values in two different executions.
\item
  \refqualclass{checker/nondeterminism/qual}{OrderNonDet} applies only to
  collections and indicates that the collection will have the same
  elements, but in a possibly different order, in two different
  executions.
 \item
  \refqualclass{checker/nondeterminism/qual}{Det} indicates that
  the collection will have the same elements, in the same order across all executions.
  \code{@OrderNonDet} is a supertype of \code{@Det}.
   It is the default qualifier.
\item
  \refqualclass{checker/nondeterminism/qual}{PolyDet and PolyDet2} are qualifiers that are
  polymorphic over nondeterminism (see Section~\ref{qualifier-polymorphism}).
\end{itemize}


\section{Valid annotations on Collections\label{nondeterminism-type-validity}}
The annotations on Collections must satisfy the constraint that the annotation on type parameter of a Collection must be a
subtype of the annotation on the Collection itself. Here are a few examples illustrating this.

\subsection{Examples\label{nondeterminism-examples}}
\begin{figure}
	\begin{enumerate}
		\item @Det List<@Det Integer> 
		\item @ValueNonDet List<@OrderNonDet Set<@Det String>> 
	\end{enumerate}
\caption{Valid types}
\end{figure}

\begin{figure}
	\begin{enumerate}
		\item @Det Set<@ValueNonDetDet Integer> : The @Det annotation on Set means that iterating over its elements will produce the same elements in the exact same order across executions. But the @ValueNonDet annotation on Integer violates this guarantee. Therefore, this is an invalid type annotation.
		\item @ValueNonDet List<@OrderNonDet String> - This is invalid because @OrderNonDet can be used only with Collections but it is used with a String here.
	\end{enumerate}
\caption{Invalid types}
\end{figure}

Figure~\ref{fig-nondeterminism-valid-types} shows the valid annotations on Collections and their type parameters. 
The Cells marked XXX are the invalid ones.
\begin{figure}
	\centering
	\begin{tabular}{|l|l|l|l|l|}
		\hline
		& 		\multicolumn{4}{l|}{Type Parameter}		                                                                   \\ \hline
		&             & ValueNonDet                                     & OrderNonDet              & Det \\ \cline{2-5} 
		Collection    & ValueNonDet &                                                 &                          &     \\ \cline{2-5} 
		& OrderNonDet &   XXX  &                          &     \\ \cline{2-5} 
		& Det         &         XXX               &  	XXX	&     \\ \hline
	\end{tabular}
	\caption{Valid Collections}
	\label{fig-nondeterminism-valid-types}
\end{figure}

Formally, the type validity rule is stated as follows:

\begin{prooftree}
	\AxiomC{is\_Collection\_Type(tc)}
	\AxiomC{outer\_type(tx) <= tc}
	\BinaryInfC{|- : tc<tx> }
\end{prooftree}

\begin{verbatim}
Type outer\_type( Type tx )
{
    if ( ! is\_Generic\_type(tx) )
        return tx
    Assert (tx == ty<tz>)
        return ty
}
\end{verbatim}

\section{Library Annotations\label{nondeterminism-library-annotations}}
\subsection{Methods common to Lists and Sets\label{nondeterminism-library-annotations-methods}}
In the type annotations that follow, @Poly and @Poly2 are polymorphic annotations. The $\downarrow$ is a function
that converts @OrderNonDet to @Det. It leaves the other annotations unchanged. For instance, if @Poly turns out to be
@OrderNonDet, @Poly$\downarrow$ converts it to @Det. 
\begin{description}
	\item[@Poly1$\downarrow$  boolean add (@Poly1 List <@Poly2 E> this, @Poly2 E e)] Suppose the List is of
	type @OrderNonDet List<@Det Integer>, this annotation ensures that the element to be added (E e) must be @Det. This is
	done with the help of @Poly2. The return type in this case will be annotated as @Det because of the $\downarrow$ function.
	\item[@Poly1$\downarrow$  boolean contains (@Poly1 List <@Poly2 E> this, @Poly2 E e)] 
	\item[@Poly1$\downarrow$  int size (@Poly1 List <@Poly2 E> this)] 
\end{description}

\section{Error reporting\label{nondeterminism-error-reporting}}
In addition to its usual type mismatch errors, the checker reports the following:
\begin{enumerate}
	\item A \code{print} statement if any of its arguments has the type annotation @ValueNonDet or @OrderNonDet.	
\end{enumerate}
